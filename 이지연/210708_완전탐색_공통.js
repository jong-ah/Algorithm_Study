//? 프로그래머스 레벨2 카펫

    //= Test case brown = 24, yellow=24  return [8, 6]

    //! Point
    // yellow와 brown의 관계에 대해서 파악을 해야한다.
    // 각각 가로와 세로의 길이가 1인 격자로 이루어져있다고 가정을 하면, 
    // 전체카펫의 가로길이는 노란색의 가로길이 + 2 이고, 세로길이는 노란색의 가로길이 + 2 가 된다.

    // 노란색 격자의 수 === 노란색의 넓이 이고 갈색 격자의 수 === 갈색의 넓이
    // 따라서 yellow + brown === 전체 넓이

    // 결과값을 구하는 방법은 두가지가 있다. 
    // 1. 전체넓이를 구해서 노란색의 넓이와 갈색의 넓이를 더한 것과 같으면 정답(내가 사용한 방법)
    // 2. (노란색 가로의 길이 + 노란색 세로의 길이)*2 + 4 === brown 를 만족하면 정답


    //* 결과로 반환될 수 있는 모든 값을 배열에 넣고 완전탐색을 해서 조건에 맞는 값을 구한다.
    //& 단, 가로길이는 세로와 같거나 길다.
    //& 단, 가로와 세로의 길이는 3이상이다. 
    // 전체 넓이가 48이라면 가로와 세로의 길이를 담은 가능한 가로와 세로길이는 
    // [48, 1], [24, 2], [16, 3], [12, 4], [8, 6], [6, 8], [4, 12], [3, 16], [2, 24], [1, 48] 인데, 
    // 사실 [16, 3], [12, 4], [8, 6]을 제외하고 나머지는 답이 될 수 없다. 
    // 답이 될 수 있는 것들 중에 조건에 만족하는 것을 구한다. 

    // 전체 넓이의 가로와 세로의 길이를 각각 요소로 하는 배열을 담기 위해서는 전체 넓이의 약수를 이용한다. 
    // 약수를 찾기 위해서 모든 숫자로 나누어떨어지는 값을 찾는 것은 효율적이지 못하므로 제곱근 이하의 가장 큰 정수까지만 고려하면 된다(코플릿 자료구조 19번 빼빼로데이 참고).
    // 약수를 이용하여 가능한 가로와 세로의 조합을 담은 배열을 만들고 완전탐색으로 조건에 만족하는 값을 찾는다.

    //# 결과를 찾는 수고를 덜기 위해서, 전체넓이의 약수를 찾지않고 노랙색격자의  넓이의 약수로 찾으면 훨씬 적은 범위를 탐색할 수 있다.  


    function solution(brown, yellow) {
        var answer = [];
        let area = brown+yellow;
        let sqrtYellow = Math.floor(Math.sqrt(yellow))  // yellow의 제곱근이하의 가장 큰 수를 구한다. 

        // sqrtYellow 이용해서 전체넓이의 가로와 세로의 길이를 각각 담은 배열을 요소로하는 2차원 배열을 만든다. 
        let arr = new Array(sqrtYellow).fill(0).map((el, i) => [yellow/(i+1)+2, (i+1)+2])  
        
        for(let el of arr) {  // el은 [카펫의 가로길이, 가펫의 세로길이]
            if(el[0]*el[1] === area && el[0] >= el[1]) { // el의 요소를 곱한 값은 전체넓이 
                answer = el
                break;
            }
        }
        
        return answer;
    }


//? 완전탐색 알고리즘 문제유형
// 1. 최적거래 문제: 일정기간 동안의 금 가격이 주어져 있다. 이 기간 중 며칠에 금을 사고 며칠에 금을 팔았을 때 이윤을 최대화할 수 있는지 알고 싶다. 금을 사고 파는 최적의 두 날짜를 구하라. 
// 2. 배낭문제: 멱집합을 구해서 완전탐색 전략에 따라 각 상품 조합의 총 무게와 판매가를 하나씩 확인. 

//! 완전탐색의 시간복잡도? 주어지는 데이터의 크기가 N이라면 O(2^N)
// => 대부분의 완전탐색 문제는 N의 크기가 매우 작다. 

//* 완전탐색 자체가 알고리즘은 아니기 때문에 완전 탐색 방법을 이용하기 위해서는 DFS나 BFS, 재귀함수 등을 이용한다. 


