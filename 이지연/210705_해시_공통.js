//? 프로그래머스 레벨3 베스트앨범
    //= Test case 01
        //& genres = ['classic', 'pop', 'classic', 'classic', 'pop'], plays = [500, 600, 150, 800, 2500]
        //& answer => [4, 1, 3, 0]
    //= Test case 02
        //& genres = ['A', 'B', 'C', 'D'], plays = [1, 2, 3, 1]
        //& answer => [2, 1, 0, 3]

    //! Point
    // 장르와 재생횟수를 담은 두 개의 배열을 하나 만들어서 조건에 따라 sort 메소드를 사용해서 문제를 해결해야하는데, 최종적으로 리턴해야하는 값은 처음 주어진 고유번호(===genres의 인덱스)이므로 장르와 재생횟수, 고유번호를 모두 담은 배열을 하나 만들어 놓고 문제를 해결해야 올바른 결과를 도출할 수 있다.
    // 각 장르 별로 총 재생횟수를 담은 배열을 만들어서 내림차순으로 정리해서 어떤 순서로 수록 해야할지 고려해야한다. 
    // 최종 결과값을 리턴하는데 고려되어야할 조건은 다음과 같다.  
    // 1. 총 재생횟수가 많은 장르를 기준으로
    // 2. 장르별로 묶에서
    // 3. 각 장르 내에 여러개의 곡이 있어도 장르 별로 두 곡씩만 수록하는데 만약 장르 내에 한 곡만 존재하면 한 곡만 수록
    // 4. 재생횟수가 같다면 고유 번호가 낮은 노래를 먼저 수록


function solution(genres, plays) {
    let answer = [];
    
    // genres를 map 메소드를 이용하여 장르, 재생횟수, 고유번호를 담은 배열을 요소로 하는 2차원 배열로 만든다. 
    let lists = genres.map((el, i) => {
        return [el, plays[i], i]
    })

    // 가장 많이 재생된 장르를 찾기위해서 새로운 배열을 하나 만들고 [장르, 총 재생횟수]를 요소로 하는 2차원 배열로 만든다. 
    let mostPlays = []
    for(let el of lists) {
        let set = mostPlays.findIndex(genre => genre[0] === el[0])
        if(set === -1) {
            mostPlays.push([el[0], el[1]])
        } else {
            mostPlays[set][1] += el[1]
        }
    }
    // 배열을 총 재생횟수를 기준으로 내림차순으로 정리하고
    mostPlays.sort((a,b) => b[1]-a[1])
    

    // mostPlays의 배열의 길이가 수록해야할 장르의 숫자이고 각 장르 별로 두 곡(또는 한 곡)을 수록하기 위해 아래를 실행한다. 
    mostPlays.forEach(el => {
        
        let curGenre = lists.filter(list => list[0] === el[0])  // lists배열에서 장르가 같은 것만 골라서 새로운 배열에 담는다. 
        curGenre.sort((a,b) => b[1] - a[1])  // 재생횟수를 기준으로 내림차순으로 정리하고
        answer.push(curGenre[0][2])  // 현재 장르의 첫 번째 요소의 고유번호를 answer에 push한다.  
        
        if( curGenre.length > 1) { // 만약 현재 장르에 두 곡이상이라면 두 번째 요소의 고유번호도 answer에 push한다.
            answer.push(curGenre[1][2])
        }
    })
    
    return answer;
}




//? 해시 함수(hash function)
// 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다. 해시 함수에 의해 얻어지는 값은 해시 값, 해시 코드, 해시 체크섬 또는 간단하게 해시라고 한다. 
// 해시 테이블이라는 자료구조에 사용. 매우 빠른 데이터 검색을 위한 컴퓨터 소프트웨어에 널리 사용된다. 해시 함수는 큰 파일에서 중복되는 레코드를 찾을 수 있기 때문에 데이터베이스 검색이나 테이블 검색의 속도를 가속할 수 있다. 
// 암호학에서도 사용될 수 있다. 암호용 해시 함수는 매핑된 해싱 값만을 알아가지고는 원래 입력 값을 알아내기 힘들다는 사실에 의해 사용될 수 있다.
// 전송된 데이터의 무결성을 확인해주는 데 사용되기도 하는데, 메시지가 누구에게서 온 것인지 입증해주는 HMAC를 구성하는 블록으로 사용된다. 해시 함수는 결정론적으로 작동해야 하며, 따라서 두 해시 값이 다르다면 그 해시값에 대한 원래 데이터도 달라야 한다. (역은 성립하지 않는다) 