//! 문제 이해
/*
    프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.
    또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 
    이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.
    먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 
    각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 
    각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.
*/

//! 제한 사항
//? 1. 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.
//? 2. 작업 진도는 100 미만의 자연수입니다.
//? 3. 작업 속도는 100 이하의 자연수입니다.
//? 4.배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다.
//? 4. 예를 들어 진도율이 95 % 인 작업의 개발 속도가 하루에 4 % 라면 배포는 2일 뒤에 이루어집니다.

function solution(progresses, speeds) {
  //? 1. 문제 이해
  /*
    예전에 코드스테이츠에서 풀었던 문제와 똑같은 유형의 문제이다.
    다만 조금 다르게 풀었는데 우선 progresses 에서 주어진 주어진 완성도에서 speeds 를 이용해 계산해서
    걸리는 일 수를 days 에 저장해준다.
    그리고 maxDay 라는 변수를 만들어서 맨 앞의 값을 저장해준다.
    for 문을 days 배열에서 돌린다.
    days 의 현재 요소가 maxDay 보다 작다면 result 배열에 += 1 을 해준다.
    만약 maxDay 가 더 크다면 maxDay 의 값을 새로 갱신해주고, 다음 result 의 요소에 1 을 넣어준다.
  */

  //? 2. 시간복잡도
  //* map 을 사용하고 for 문을 사용하여 O(2n) 이 될테지만 상수는 빼니까 결과적으로 O(n) 의 시간복잡도를 가진다.

  //? 3. 개선점
  //* 맨 위에 다른 사람의 풀이와 같은 풀이이다. 가장 효과적인 코드인 것 같다.
  //* 다른 사람들이 푼 것 중에 O(n^2) 의 시간복잡도를 가지는 코드도 있었어서 O(n) 으로 끝나는 이 코드가 가장 좋아보인다.
  let result = [0];
  let days = progresses.map((el, idx) => Math.ceil((100 - el) / speeds[idx]));
  let maxDay = days[0];

  for (let i = 0, j = 0; i < days.length; i++) {
    if (days[i] <= maxDay) {
      result[j] += 1;
    } else {
      maxDay = days[i];
      result[++j] = 1;
    }
  }

  return result;
}
