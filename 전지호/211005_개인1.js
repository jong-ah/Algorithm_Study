//! 문제 설명
/*
    일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다.
    그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다.
    이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다.
    이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다.

    1. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.
    2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.
    3. 그렇지 않으면 J를 인쇄합니다.

    예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 
    중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다.

    내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다.
    위의 예에서 C는 1번째로, A는 3번째로 인쇄됩니다.

    현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 
    내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때,
    내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return 하도록 solution 함수를 작성해주세요.
*/

//! 제한 사항
//? 1. 현재 대기목록에는 1개 이상 100개 이하의 문서가 있습니다.
//? 2. 인쇄 작업의 중요도는 1~9로 표현하며 숫자가 클수록 중요하다는 뜻입니다.
//? 3. location은 0 이상 (현재 대기목록에 있는 작업 수 - 1) 이하의 값을 가지며
//? 3. 대기목록의 가장 앞에 있으면 0, 두 번째에 있으면 1로 표현합니다.

function solution(priorities, location) {
  //? 1. 문제이해
  /*
    이번 문제는 Stack 과 Queue 에 관한 문제였다.
    내가 요청한 문서의 위치 location, 중요도가 담겨있는 배열 priorities 가 주어졌다.
    while 을 통해 무한 반복을 돌렸으며 특정 조건이 만족되면 break 를 사용하여 반복을 벗어나주었다.
    문제에 나와있는대로 현재 출력하려는 J 보다 중요도가 큰 값이 priorities 안에 남아있다면 문서의 맨 뒤로 보내버렸다.
    그리고 가장 중요도가 큰 순서라면 새 배열 temp 를 만들어 push 를 해주었다.
    그 뒤에 result 를 원소의 순서로 사용하여 2차원 배열 형태의 temp 배열의 [1] 에는 index 를 담아주었으므로
    location 과 같다면 break 를 사용해 반복을 벗어나고 만약 같지 않다면 result++ 을 해주면서 index 를 늘려주는
    형식으로 풀었다.
  */

  //? 2. 시간복잡도
  //* while 을 돌아주고 있고 내부에선 map, shift, some 을 사용하고 있다.
  //* map 의 시간복잡도는 O(logN) 의 시간복잡도, shift 는 O(n), some 은 정보가 없다.
  //* map 보다 shift 가 크므로 O(n * n) 의 시간복잡도가 될 것이다.
  //* 만약 some 이 제일 복잡도가 컸다면 O(n * some()) 이 될 것이다.

  //? 3. 개선점
  //* 다른 사람들의 풀이코드를 보았을때 전부 while 내부에서 some 을 사용해주거나 shift 대신 slice 를 사용한 사람도 있었다.
  //* 시간 복잡도 상으로는 개선점이 없어보여서 굳이 수정할 필요는 없어보인다.

  let result = 0;

  const arr = priorities.map((el, idx) => [el, idx]);
  const temp = [];

  while (true) {
    const curr = arr.shift();

    if (arr.some((el) => curr[0] < el[0])) {
      arr.push(curr);
    } else {
      temp.push(curr);

      if (temp[result][1] == location) {
        break;
      } else {
        result++;
      }
    }
  }

  return result + 1;
}

//! 입출력 예시
console.log(solution([2, 1, 3, 2], 2)); //* 결과: 1
console.log(solution([1, 1, 9, 1, 1, 1], 0)); //* 결과: 5
